// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_POSITIONSCHEMA_SIVERTAPI_POSUPD_H_
#define FLATBUFFERS_GENERATED_POSITIONSCHEMA_SIVERTAPI_POSUPD_H_

#include "flatbuffers/flatbuffers.h"

namespace SivertAPI {
namespace PosUpd {

struct Vec3API;

struct EEBL;

struct GSCMstruct;

struct VehInfo;

struct GscmInfo;

struct Channel;

struct SpectrumValue;

struct PosAPI;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3API FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  int32_t id_;

 public:
  Vec3API() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3API));
  }
  Vec3API(float _x, float _y, float _z, int32_t _id)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        id_(flatbuffers::EndianScalar(_id)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3API, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EEBL FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t triggered_;
  int8_t padding0__;  int16_t padding1__;
  int32_t VehID_;

 public:
  EEBL() {
    memset(static_cast<void *>(this), 0, sizeof(EEBL));
  }
  EEBL(bool _triggered, int32_t _VehID)
      : triggered_(flatbuffers::EndianScalar(static_cast<uint8_t>(_triggered))),
        padding0__(0),
        padding1__(0),
        VehID_(flatbuffers::EndianScalar(_VehID)) {
    (void)padding0__;    (void)padding1__;
  }
  bool triggered() const {
    return flatbuffers::EndianScalar(triggered_) != 0;
  }
  int32_t VehID() const {
    return flatbuffers::EndianScalar(VehID_);
  }
};
FLATBUFFERS_STRUCT_END(EEBL, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) VehInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;
  float timeStamp_;

 public:
  VehInfo() {
    memset(static_cast<void *>(this), 0, sizeof(VehInfo));
  }
  VehInfo(int32_t _id, float _timeStamp)
      : id_(flatbuffers::EndianScalar(_id)),
        timeStamp_(flatbuffers::EndianScalar(_timeStamp)) {
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  float timeStamp() const {
    return flatbuffers::EndianScalar(timeStamp_);
  }
};
FLATBUFFERS_STRUCT_END(VehInfo, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) GscmInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Tx_;
  int32_t Rx_;
  double rss_;

 public:
  GscmInfo() {
    memset(static_cast<void *>(this), 0, sizeof(GscmInfo));
  }
  GscmInfo(int32_t _Tx, int32_t _Rx, double _rss)
      : Tx_(flatbuffers::EndianScalar(_Tx)),
        Rx_(flatbuffers::EndianScalar(_Rx)),
        rss_(flatbuffers::EndianScalar(_rss)) {
  }
  int32_t Tx() const {
    return flatbuffers::EndianScalar(Tx_);
  }
  int32_t Rx() const {
    return flatbuffers::EndianScalar(Rx_);
  }
  double rss() const {
    return flatbuffers::EndianScalar(rss_);
  }
};
FLATBUFFERS_STRUCT_END(GscmInfo, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Channel FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t TxID_;
  int32_t RxID_;
  int32_t ChannelIDinfo_;

 public:
  Channel() {
    memset(static_cast<void *>(this), 0, sizeof(Channel));
  }
  Channel(int32_t _TxID, int32_t _RxID, int32_t _ChannelIDinfo)
      : TxID_(flatbuffers::EndianScalar(_TxID)),
        RxID_(flatbuffers::EndianScalar(_RxID)),
        ChannelIDinfo_(flatbuffers::EndianScalar(_ChannelIDinfo)) {
  }
  int32_t TxID() const {
    return flatbuffers::EndianScalar(TxID_);
  }
  int32_t RxID() const {
    return flatbuffers::EndianScalar(RxID_);
  }
  int32_t ChannelIDinfo() const {
    return flatbuffers::EndianScalar(ChannelIDinfo_);
  }
};
FLATBUFFERS_STRUCT_END(Channel, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpectrumValue FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t ChannelID_;
  int32_t padding0__;
  double PSDGainCoefficient_;
  int32_t CoefInd_;
  int32_t padding1__;

 public:
  SpectrumValue() {
    memset(static_cast<void *>(this), 0, sizeof(SpectrumValue));
  }
  SpectrumValue(int32_t _ChannelID, double _PSDGainCoefficient, int32_t _CoefInd)
      : ChannelID_(flatbuffers::EndianScalar(_ChannelID)),
        padding0__(0),
        PSDGainCoefficient_(flatbuffers::EndianScalar(_PSDGainCoefficient)),
        CoefInd_(flatbuffers::EndianScalar(_CoefInd)),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  int32_t ChannelID() const {
    return flatbuffers::EndianScalar(ChannelID_);
  }
  double PSDGainCoefficient() const {
    return flatbuffers::EndianScalar(PSDGainCoefficient_);
  }
  int32_t CoefInd() const {
    return flatbuffers::EndianScalar(CoefInd_);
  }
};
FLATBUFFERS_STRUCT_END(SpectrumValue, 24);

struct GSCMstruct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USEGSCM = 4,
    VT_RSS = 6
  };
  bool UseGSCM() const {
    return GetField<uint8_t>(VT_USEGSCM, 0) != 0;
  }
  double RSS() const {
    return GetField<double>(VT_RSS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USEGSCM) &&
           VerifyField<double>(verifier, VT_RSS) &&
           verifier.EndTable();
  }
};

struct GSCMstructBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_UseGSCM(bool UseGSCM) {
    fbb_.AddElement<uint8_t>(GSCMstruct::VT_USEGSCM, static_cast<uint8_t>(UseGSCM), 0);
  }
  void add_RSS(double RSS) {
    fbb_.AddElement<double>(GSCMstruct::VT_RSS, RSS, 0.0);
  }
  explicit GSCMstructBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSCMstructBuilder &operator=(const GSCMstructBuilder &);
  flatbuffers::Offset<GSCMstruct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GSCMstruct>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSCMstruct> CreateGSCMstruct(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool UseGSCM = false,
    double RSS = 0.0) {
  GSCMstructBuilder builder_(_fbb);
  builder_.add_RSS(RSS);
  builder_.add_UseGSCM(UseGSCM);
  return builder_.Finish();
}

struct PosAPI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GSCM = 4,
    VT_GSCMVECTOR = 6,
    VT_CITS = 8,
    VT_POS = 10,
    VT_SUPPL = 12,
    VT_TERMINATENS3 = 14,
    VT_GSCMSPECTRUCHANNELS = 16,
    VT_SPECTRUMINFO = 18,
    VT_NUMBEROFFREQUNCIESPERCHANNEL = 20,
    VT_V2XSTACK = 22
  };
  const GSCMstruct *GSCM() const {
    return GetPointer<const GSCMstruct *>(VT_GSCM);
  }
  const flatbuffers::Vector<const GscmInfo *> *GSCMvector() const {
    return GetPointer<const flatbuffers::Vector<const GscmInfo *> *>(VT_GSCMVECTOR);
  }
  const flatbuffers::Vector<const EEBL *> *CITS() const {
    return GetPointer<const flatbuffers::Vector<const EEBL *> *>(VT_CITS);
  }
  const flatbuffers::Vector<const Vec3API *> *pos() const {
    return GetPointer<const flatbuffers::Vector<const Vec3API *> *>(VT_POS);
  }
  const flatbuffers::Vector<const VehInfo *> *Suppl() const {
    return GetPointer<const flatbuffers::Vector<const VehInfo *> *>(VT_SUPPL);
  }
  bool terminateNS3() const {
    return GetField<uint8_t>(VT_TERMINATENS3, 0) != 0;
  }
  const flatbuffers::Vector<const SpectrumValue *> *GSCMSpectruChannels() const {
    return GetPointer<const flatbuffers::Vector<const SpectrumValue *> *>(VT_GSCMSPECTRUCHANNELS);
  }
  const flatbuffers::Vector<const Channel *> *SpectrumInfo() const {
    return GetPointer<const flatbuffers::Vector<const Channel *> *>(VT_SPECTRUMINFO);
  }
  int32_t NumberOfFrequnciesPerChannel() const {
    return GetField<int32_t>(VT_NUMBEROFFREQUNCIESPERCHANNEL, 0);
  }
  const flatbuffers::String *V2Xstack() const {
    return GetPointer<const flatbuffers::String *>(VT_V2XSTACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GSCM) &&
           verifier.VerifyTable(GSCM()) &&
           VerifyOffset(verifier, VT_GSCMVECTOR) &&
           verifier.VerifyVector(GSCMvector()) &&
           VerifyOffset(verifier, VT_CITS) &&
           verifier.VerifyVector(CITS()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(pos()) &&
           VerifyOffset(verifier, VT_SUPPL) &&
           verifier.VerifyVector(Suppl()) &&
           VerifyField<uint8_t>(verifier, VT_TERMINATENS3) &&
           VerifyOffset(verifier, VT_GSCMSPECTRUCHANNELS) &&
           verifier.VerifyVector(GSCMSpectruChannels()) &&
           VerifyOffset(verifier, VT_SPECTRUMINFO) &&
           verifier.VerifyVector(SpectrumInfo()) &&
           VerifyField<int32_t>(verifier, VT_NUMBEROFFREQUNCIESPERCHANNEL) &&
           VerifyOffset(verifier, VT_V2XSTACK) &&
           verifier.VerifyString(V2Xstack()) &&
           verifier.EndTable();
  }
};

struct PosAPIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GSCM(flatbuffers::Offset<GSCMstruct> GSCM) {
    fbb_.AddOffset(PosAPI::VT_GSCM, GSCM);
  }
  void add_GSCMvector(flatbuffers::Offset<flatbuffers::Vector<const GscmInfo *>> GSCMvector) {
    fbb_.AddOffset(PosAPI::VT_GSCMVECTOR, GSCMvector);
  }
  void add_CITS(flatbuffers::Offset<flatbuffers::Vector<const EEBL *>> CITS) {
    fbb_.AddOffset(PosAPI::VT_CITS, CITS);
  }
  void add_pos(flatbuffers::Offset<flatbuffers::Vector<const Vec3API *>> pos) {
    fbb_.AddOffset(PosAPI::VT_POS, pos);
  }
  void add_Suppl(flatbuffers::Offset<flatbuffers::Vector<const VehInfo *>> Suppl) {
    fbb_.AddOffset(PosAPI::VT_SUPPL, Suppl);
  }
  void add_terminateNS3(bool terminateNS3) {
    fbb_.AddElement<uint8_t>(PosAPI::VT_TERMINATENS3, static_cast<uint8_t>(terminateNS3), 0);
  }
  void add_GSCMSpectruChannels(flatbuffers::Offset<flatbuffers::Vector<const SpectrumValue *>> GSCMSpectruChannels) {
    fbb_.AddOffset(PosAPI::VT_GSCMSPECTRUCHANNELS, GSCMSpectruChannels);
  }
  void add_SpectrumInfo(flatbuffers::Offset<flatbuffers::Vector<const Channel *>> SpectrumInfo) {
    fbb_.AddOffset(PosAPI::VT_SPECTRUMINFO, SpectrumInfo);
  }
  void add_NumberOfFrequnciesPerChannel(int32_t NumberOfFrequnciesPerChannel) {
    fbb_.AddElement<int32_t>(PosAPI::VT_NUMBEROFFREQUNCIESPERCHANNEL, NumberOfFrequnciesPerChannel, 0);
  }
  void add_V2Xstack(flatbuffers::Offset<flatbuffers::String> V2Xstack) {
    fbb_.AddOffset(PosAPI::VT_V2XSTACK, V2Xstack);
  }
  explicit PosAPIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PosAPIBuilder &operator=(const PosAPIBuilder &);
  flatbuffers::Offset<PosAPI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PosAPI>(end);
    return o;
  }
};

inline flatbuffers::Offset<PosAPI> CreatePosAPI(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GSCMstruct> GSCM = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GscmInfo *>> GSCMvector = 0,
    flatbuffers::Offset<flatbuffers::Vector<const EEBL *>> CITS = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3API *>> pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const VehInfo *>> Suppl = 0,
    bool terminateNS3 = false,
    flatbuffers::Offset<flatbuffers::Vector<const SpectrumValue *>> GSCMSpectruChannels = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Channel *>> SpectrumInfo = 0,
    int32_t NumberOfFrequnciesPerChannel = 0,
    flatbuffers::Offset<flatbuffers::String> V2Xstack = 0) {
  PosAPIBuilder builder_(_fbb);
  builder_.add_V2Xstack(V2Xstack);
  builder_.add_NumberOfFrequnciesPerChannel(NumberOfFrequnciesPerChannel);
  builder_.add_SpectrumInfo(SpectrumInfo);
  builder_.add_GSCMSpectruChannels(GSCMSpectruChannels);
  builder_.add_Suppl(Suppl);
  builder_.add_pos(pos);
  builder_.add_CITS(CITS);
  builder_.add_GSCMvector(GSCMvector);
  builder_.add_GSCM(GSCM);
  builder_.add_terminateNS3(terminateNS3);
  return builder_.Finish();
}

inline flatbuffers::Offset<PosAPI> CreatePosAPIDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GSCMstruct> GSCM = 0,
    const std::vector<GscmInfo> *GSCMvector = nullptr,
    const std::vector<EEBL> *CITS = nullptr,
    const std::vector<Vec3API> *pos = nullptr,
    const std::vector<VehInfo> *Suppl = nullptr,
    bool terminateNS3 = false,
    const std::vector<SpectrumValue> *GSCMSpectruChannels = nullptr,
    const std::vector<Channel> *SpectrumInfo = nullptr,
    int32_t NumberOfFrequnciesPerChannel = 0,
    const char *V2Xstack = nullptr) {
  auto GSCMvector__ = GSCMvector ? _fbb.CreateVectorOfStructs<GscmInfo>(*GSCMvector) : 0;
  auto CITS__ = CITS ? _fbb.CreateVectorOfStructs<EEBL>(*CITS) : 0;
  auto pos__ = pos ? _fbb.CreateVectorOfStructs<Vec3API>(*pos) : 0;
  auto Suppl__ = Suppl ? _fbb.CreateVectorOfStructs<VehInfo>(*Suppl) : 0;
  auto GSCMSpectruChannels__ = GSCMSpectruChannels ? _fbb.CreateVectorOfStructs<SpectrumValue>(*GSCMSpectruChannels) : 0;
  auto SpectrumInfo__ = SpectrumInfo ? _fbb.CreateVectorOfStructs<Channel>(*SpectrumInfo) : 0;
  auto V2Xstack__ = V2Xstack ? _fbb.CreateString(V2Xstack) : 0;
  return SivertAPI::PosUpd::CreatePosAPI(
      _fbb,
      GSCM,
      GSCMvector__,
      CITS__,
      pos__,
      Suppl__,
      terminateNS3,
      GSCMSpectruChannels__,
      SpectrumInfo__,
      NumberOfFrequnciesPerChannel,
      V2Xstack__);
}

inline const SivertAPI::PosUpd::PosAPI *GetPosAPI(const void *buf) {
  return flatbuffers::GetRoot<SivertAPI::PosUpd::PosAPI>(buf);
}

inline const SivertAPI::PosUpd::PosAPI *GetSizePrefixedPosAPI(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SivertAPI::PosUpd::PosAPI>(buf);
}

inline bool VerifyPosAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SivertAPI::PosUpd::PosAPI>(nullptr);
}

inline bool VerifySizePrefixedPosAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SivertAPI::PosUpd::PosAPI>(nullptr);
}

inline void FinishPosAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SivertAPI::PosUpd::PosAPI> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPosAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SivertAPI::PosUpd::PosAPI> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PosUpd
}  // namespace SivertAPI

#endif  // FLATBUFFERS_GENERATED_POSITIONSCHEMA_SIVERTAPI_POSUPD_H_
