// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_POSITIONSCHEMASINGLEGSCMLINK_SIVERTAPI_POSUPDNOMULTIGSCM_H_
#define FLATBUFFERS_GENERATED_POSITIONSCHEMASINGLEGSCMLINK_SIVERTAPI_POSUPDNOMULTIGSCM_H_

#include "flatbuffers/flatbuffers.h"

namespace SivertAPI {
namespace PosUpdNoMultiGSCM {

struct Vec3API;

struct EEBL;

struct GSCMstruct;

struct VehInfo;

struct PosAPI;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3API FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3API() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3API));
  }
  Vec3API(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3API, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) VehInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;
  float timeStamp_;

 public:
  VehInfo() {
    memset(static_cast<void *>(this), 0, sizeof(VehInfo));
  }
  VehInfo(int32_t _id, float _timeStamp)
      : id_(flatbuffers::EndianScalar(_id)),
        timeStamp_(flatbuffers::EndianScalar(_timeStamp)) {
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  float timeStamp() const {
    return flatbuffers::EndianScalar(timeStamp_);
  }
};
FLATBUFFERS_STRUCT_END(VehInfo, 8);

struct EEBL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIGGERED = 4,
    VT_VEHID = 6
  };
  bool triggered() const {
    return GetField<uint8_t>(VT_TRIGGERED, 0) != 0;
  }
  int32_t VehID() const {
    return GetField<int32_t>(VT_VEHID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGERED) &&
           VerifyField<int32_t>(verifier, VT_VEHID) &&
           verifier.EndTable();
  }
};

struct EEBLBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggered(bool triggered) {
    fbb_.AddElement<uint8_t>(EEBL::VT_TRIGGERED, static_cast<uint8_t>(triggered), 0);
  }
  void add_VehID(int32_t VehID) {
    fbb_.AddElement<int32_t>(EEBL::VT_VEHID, VehID, 0);
  }
  explicit EEBLBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EEBLBuilder &operator=(const EEBLBuilder &);
  flatbuffers::Offset<EEBL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EEBL>(end);
    return o;
  }
};

inline flatbuffers::Offset<EEBL> CreateEEBL(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool triggered = false,
    int32_t VehID = 0) {
  EEBLBuilder builder_(_fbb);
  builder_.add_VehID(VehID);
  builder_.add_triggered(triggered);
  return builder_.Finish();
}

struct GSCMstruct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USEGSCM = 4,
    VT_RSS = 6
  };
  bool UseGSCM() const {
    return GetField<uint8_t>(VT_USEGSCM, 0) != 0;
  }
  double RSS() const {
    return GetField<double>(VT_RSS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USEGSCM) &&
           VerifyField<double>(verifier, VT_RSS) &&
           verifier.EndTable();
  }
};

struct GSCMstructBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_UseGSCM(bool UseGSCM) {
    fbb_.AddElement<uint8_t>(GSCMstruct::VT_USEGSCM, static_cast<uint8_t>(UseGSCM), 0);
  }
  void add_RSS(double RSS) {
    fbb_.AddElement<double>(GSCMstruct::VT_RSS, RSS, 0.0);
  }
  explicit GSCMstructBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GSCMstructBuilder &operator=(const GSCMstructBuilder &);
  flatbuffers::Offset<GSCMstruct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GSCMstruct>(end);
    return o;
  }
};

inline flatbuffers::Offset<GSCMstruct> CreateGSCMstruct(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool UseGSCM = false,
    double RSS = 0.0) {
  GSCMstructBuilder builder_(_fbb);
  builder_.add_RSS(RSS);
  builder_.add_UseGSCM(UseGSCM);
  return builder_.Finish();
}

struct PosAPI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GSCM = 4,
    VT_CITS = 6,
    VT_POS = 8,
    VT_SUPPL = 10,
    VT_TERMINATENS3 = 12
  };
  const GSCMstruct *GSCM() const {
    return GetPointer<const GSCMstruct *>(VT_GSCM);
  }
  const EEBL *CITS() const {
    return GetPointer<const EEBL *>(VT_CITS);
  }
  const flatbuffers::Vector<const Vec3API *> *pos() const {
    return GetPointer<const flatbuffers::Vector<const Vec3API *> *>(VT_POS);
  }
  const flatbuffers::Vector<const VehInfo *> *Suppl() const {
    return GetPointer<const flatbuffers::Vector<const VehInfo *> *>(VT_SUPPL);
  }
  bool terminateNS3() const {
    return GetField<uint8_t>(VT_TERMINATENS3, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GSCM) &&
           verifier.VerifyTable(GSCM()) &&
           VerifyOffset(verifier, VT_CITS) &&
           verifier.VerifyTable(CITS()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(pos()) &&
           VerifyOffset(verifier, VT_SUPPL) &&
           verifier.VerifyVector(Suppl()) &&
           VerifyField<uint8_t>(verifier, VT_TERMINATENS3) &&
           verifier.EndTable();
  }
};

struct PosAPIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GSCM(flatbuffers::Offset<GSCMstruct> GSCM) {
    fbb_.AddOffset(PosAPI::VT_GSCM, GSCM);
  }
  void add_CITS(flatbuffers::Offset<EEBL> CITS) {
    fbb_.AddOffset(PosAPI::VT_CITS, CITS);
  }
  void add_pos(flatbuffers::Offset<flatbuffers::Vector<const Vec3API *>> pos) {
    fbb_.AddOffset(PosAPI::VT_POS, pos);
  }
  void add_Suppl(flatbuffers::Offset<flatbuffers::Vector<const VehInfo *>> Suppl) {
    fbb_.AddOffset(PosAPI::VT_SUPPL, Suppl);
  }
  void add_terminateNS3(bool terminateNS3) {
    fbb_.AddElement<uint8_t>(PosAPI::VT_TERMINATENS3, static_cast<uint8_t>(terminateNS3), 0);
  }
  explicit PosAPIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PosAPIBuilder &operator=(const PosAPIBuilder &);
  flatbuffers::Offset<PosAPI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PosAPI>(end);
    return o;
  }
};

inline flatbuffers::Offset<PosAPI> CreatePosAPI(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GSCMstruct> GSCM = 0,
    flatbuffers::Offset<EEBL> CITS = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec3API *>> pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const VehInfo *>> Suppl = 0,
    bool terminateNS3 = false) {
  PosAPIBuilder builder_(_fbb);
  builder_.add_Suppl(Suppl);
  builder_.add_pos(pos);
  builder_.add_CITS(CITS);
  builder_.add_GSCM(GSCM);
  builder_.add_terminateNS3(terminateNS3);
  return builder_.Finish();
}

inline flatbuffers::Offset<PosAPI> CreatePosAPIDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GSCMstruct> GSCM = 0,
    flatbuffers::Offset<EEBL> CITS = 0,
    const std::vector<Vec3API> *pos = nullptr,
    const std::vector<VehInfo> *Suppl = nullptr,
    bool terminateNS3 = false) {
  auto pos__ = pos ? _fbb.CreateVectorOfStructs<Vec3API>(*pos) : 0;
  auto Suppl__ = Suppl ? _fbb.CreateVectorOfStructs<VehInfo>(*Suppl) : 0;
  return SivertAPI::PosUpdNoMultiGSCM::CreatePosAPI(
      _fbb,
      GSCM,
      CITS,
      pos__,
      Suppl__,
      terminateNS3);
}

inline const SivertAPI::PosUpdNoMultiGSCM::PosAPI *GetPosAPI(const void *buf) {
  return flatbuffers::GetRoot<SivertAPI::PosUpdNoMultiGSCM::PosAPI>(buf);
}

inline const SivertAPI::PosUpdNoMultiGSCM::PosAPI *GetSizePrefixedPosAPI(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SivertAPI::PosUpdNoMultiGSCM::PosAPI>(buf);
}

inline bool VerifyPosAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SivertAPI::PosUpdNoMultiGSCM::PosAPI>(nullptr);
}

inline bool VerifySizePrefixedPosAPIBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SivertAPI::PosUpdNoMultiGSCM::PosAPI>(nullptr);
}

inline void FinishPosAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SivertAPI::PosUpdNoMultiGSCM::PosAPI> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPosAPIBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SivertAPI::PosUpdNoMultiGSCM::PosAPI> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PosUpdNoMultiGSCM
}  // namespace SivertAPI

#endif  // FLATBUFFERS_GENERATED_POSITIONSCHEMASINGLEGSCMLINK_SIVERTAPI_POSUPDNOMULTIGSCM_H_
